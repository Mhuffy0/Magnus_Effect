#version 430
layout(local_size_x=16, local_size_y=16) in;
layout(binding=0, r32f) uniform readonly  image2DArray fB; // post-collision
layout(binding=1, r32f) uniform writeonly image2DArray fA; // next step
layout(binding=2, r8ui) uniform uimage2D maskImg;           // solid mask
layout(binding=3, rg32f) uniform readonly image2D wallVelImg; // wall velocity

const vec2 c[9] = vec2[9](
  vec2(0,0), vec2(1,0), vec2(0,1), vec2(-1,0), vec2(0,-1),
  vec2(1,1), vec2(-1,1), vec2(-1,-1), vec2(1,-1)
);
const int opp[9] = int[9](0,3,4,1,2,7,8,5,6);
const float w[9] = float[9](4.0/9.0,1.0/9.0,1.0/9.0,1.0/9.0,1.0/9.0,1.0/36.0,1.0/36.0,1.0/36.0,1.0/36.0);

void main(){
  ivec2 p = ivec2(gl_GlobalInvocationID.xy);
  ivec2 sz = imageSize(maskImg);

  // clear center
  imageStore(fA, ivec3(p,0), imageLoad(fB, ivec3(p,0)) );

  for (int i=1;i<9;i++){
    ivec2 q = p + ivec2(c[i]);

    // boundary clamp for domain; treat outside as open copy
    q.x = clamp(q.x, 0, sz.x-1);
    q.y = clamp(q.y, 0, sz.y-1);

    // If target is solid, bounce back to current cell in opposite dir with moving-wall correction
    if (imageLoad(maskImg,q).r != 0u){
      float f_in = imageLoad(fB, ivec3(p,i)).r;
      // moving-wall correction: -2 w_i rho (c_i·u_w) / c_s^2, with rho≈sum f at p
      float rho = 0.0; for (int k=0;k<9;k++) rho += imageLoad(fB, ivec3(p,k)).r;
      vec2 uw = imageLoad(wallVelImg, q).rg;
      float corr = -2.0 * w[i] * rho * dot(c[i], uw) * 3.0; // /c_s^2 = *3
      imageStore(fA, ivec3(p,opp[i]), vec4(f_in + corr,0,0,0));
    } else {
      float f_in = imageLoad(fB, ivec3(p,i)).r;
      imageStore(fA, ivec3(q,i), vec4(f_in,0,0,0));
    }
  }
}