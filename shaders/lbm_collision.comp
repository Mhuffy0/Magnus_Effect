#version 430
layout(local_size_x=16, local_size_y=16) in;
layout(binding=0, r32f) uniform readonly  image2DArray fA; // input f_i
layout(binding=1, r32f) uniform writeonly image2DArray fB; // output f*_i
layout(binding=2, r8ui) uniform uimage2D maskImg;
layout(std140, binding=3) uniform Sim { float tau; ivec2 size; } S;

const vec2 c[9] = vec2[9](
  vec2(0,0), vec2(1,0), vec2(0,1), vec2(-1,0), vec2(0,-1),
  vec2(1,1), vec2(-1,1), vec2(-1,-1), vec2(1,-1)
);
const float w[9] = float[9](4.0/9.0,1.0/9.0,1.0/9.0,1.0/9.0,1.0/9.0,1.0/36.0,1.0/36.0,1.0/36.0,1.0/36.0);

void main(){
  ivec2 p = ivec2(gl_GlobalInvocationID.xy);
  if (any(greaterThanEqual(p, S.size))) return;

  float fi[9];
  float rho = 0.0; vec2 u = vec2(0);
  for (int i=0;i<9;i++){ float v = imageLoad(fA, ivec3(p,i)).r; fi[i]=v; rho+=v; }
  for (int i=0;i<9;i++) u += fi[i]*c[i];
  u /= max(rho, 1e-6);

  // solid nodes: leave near-equilibrium; streaming handles bounce-back
  if (imageLoad(maskImg,p).r != 0u){
    for (int i=0;i<9;i++) imageStore(fB, ivec3(p,i), vec4(fi[i],0,0,0));
    return;
  }

  float uu = dot(u,u);
  float invTau = 1.0/S.tau;
  for (int i=0;i<9;i++){
    float cu = dot(c[i], u);
    float feq = w[i]*rho*(1.0 + 3.0*cu + 4.5*cu*cu - 1.5*uu);
    float fstar = fi[i] - (fi[i]-feq)*invTau; // Î”t=1
    imageStore(fB, ivec3(p,i), vec4(fstar,0,0,0));
  }
}